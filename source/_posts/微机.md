---
title: 微机
date: 2021-05-26 11:17:15
tags: 微机
typora-root-url: ..
---

# 微机原理与汇编语言

教材《微型计算机原理与接口技术》

内容主要以8086为主要对象，包括微型计算机的基础知识、8086CPU、寻址方式、指令系统、汇编语言程序设计和存储器。

## 绪论

### 冯-诺依曼体系

存储器、运算器、控制器、输入系统、输出系统

### 数制

二进制B 、十进制D、十六进制H、BCD码



BCD码的每一位数字都用4位二进制来表示，如十进制数（327）对应BCD码（0011 0010 0111）

注意16进制与BCD码的区别：BCD码实质是**十进制数**，只是采用二进制数对0-9进行编码，所以会出现非法码。

**BCD码的加减规则：**

- 低4位有进位（AF=1）：+06H修正
- 低4位出现非法码：+66H修正
- 高四位出现非法码：+60H修正

**数制转换**

1. 二、十六进制->十进制

   权值相乘，再求累加和

2. 二进制->十六进制

   四个一组，每组用等值的十六进制代换

3. 十六进制->二进制

   一个十六进制的数，用等值的4个二进制数表示

4. 十进制->二进制

   整数：除以2取整，直到商为0，倒排余数

   小数：乘以2取整，直到乘积的小数部分为0，顺排整数

   带小数：整数、小数分别计算，再合并

### 编码

数值数据：有符号数、无符号数

非数值数据：字符、图像

**需要牢记的ASCII码：**

- 数字0-9：30H~39H
- 字母A: 41H
- 字母a: 61H
- 回车符：0DH
- 换行符：0AH

### 码制 

**原码、反码、补码**

1. 原码：有符号数的，最高位为符号位，正数的符号用0表示，负数用1表示；数值部分为该数的绝对值

   +23（17H) 的原码：0001 0111B

   -23（-17H) 的原码：1001 0111B

2. 反码：对于有符号数，符号位不变，其他各位取反

3. 补码：对于有符号数，正数不变，负数除了符号位各位取反后加1

   注意，补码的补码是原码

   -y的补码：对y的补码，所有位全部取反，再加一

   有符号n位补码的真值范围   -2^(n-1) — 2^(n-1)-1

   无符号数： 0 — 2^n-1

### 整数补码的加减运算

- 加法：（x+y)补 = （x)补 + (y)补
- 减法： （x-y)补 = （x)补 +（-y）补
- 进位C：运算后，最高位向更高位的进位值
- 溢出O：运算结果超出了运算器所能表示的范围（加数与被加数符号相同，结果的符号却相反，O=1，一定溢出）
- 判断出错：有符号数看溢出O , 无符号数看进位C（有O无C）

### 微型机的硬件结构

总线：CPU与存储器、I/O端口交换信息的公共通道

I/O接口：CPU和外部设备交换信息的中转站

**三大总线：**

- 地址总线AB：单向 访问I/O端口的地址信号
- 数据总线DB：双向 读写I/O端口的数据（有读有写当然双向)
- 控制总线CB：大部分单向，少数双向  传输CPU发出的控制命令



读：输入 外部->CPU

写：输出 CPU->外部

读内存：存储器取信息->CPU

写内存：信息->存储器

### 存储器的基础知识

1、存储器分类：

辅助存储器：磁盘、光盘

主存储器：RAM、ROM...

高速缓冲存储器：cache

2、存储器的容量由地址线“宽度”决定

20根地址线，地址范围为：00000H~FFFFFH，1M

## 8086微处理器

### 常用术语

1. 位和字节：

   位bit：计算机所能表示的最小的、最基本的数据单位

   字节byte：由8个位组成

   字word：在8086中，由两个字节组成

2. 字长：一次可以直接处理的二进制数码的位数

   与通用寄存器的位数、数据总线的宽度有关

3. 寻址能力：CPU能直接存取数据的内存地址的范围

   与地址总线的数目有关

4. 主频：时钟频率

5. MIPS：million instructions per second

### 基本功能模块

**总线接口单元BIU（bus interface unit）**： 主要由段寄存器，地址加法器和指令队列等部件构成

功能： 用于取指令，即负责在CPU内部各部件与存储器、输入/输出接口之间传送数据或指令。



**执行单元EU（Execution Unit）**：主要由通用寄存器组、算术逻辑单元和标志寄存器等部件组成

功能： 用于执行指令，即将已译码指令队列中的内部编码变成按时间顺序排列的一系列控制信息，发向处理器内部有关的部件，以完成指令的执行。

### 寄存器

1、只介绍了基本结构寄存器。

2、**基本结构寄存器**：

8个16位通用寄存器： AX BX CX DX SP BP DI SI

4个16位段寄存器： CS DS ES SS

1个16位标志寄存器：FLAGS

1个16位指令指针：IP

3、**功能**

AX   accumulater 累加器

BX   base 基地址指针

CX   count 计数寄存器

DX   data 数据寄存器

SP   stack pointer 堆栈指针

BP   base pointer 基址指针

DI    destination index 目的变址寄存器

SI source index 源变址寄存器

IP Instruction Pointer 指令指针（用户不能对 IP 进行存取操作，只能由 BIU 自行修改）

其中，SP 、BP、 DI、 SI、 IP 都可以为存储单元提供偏移地址

AH 是 AX 的高8位，而 AL 是 AX 的低8位

4、**标志寄存器**（又称 程序状态字PSW，16位）

有两类：状态标志，控制标志

状态标志: 

- ZF（Zero flag）零标志。若运算结果为0，则ZF为1，否则ZF为0
- CF（Carry Flag）进位标志。最高位向前一位产生进位或借位时，CF=1，否则CF=0
- SF（Sign Flag）符号标志。若运算结果最高位为1，则SF=1，表示该数为负数，否则SF=0，表示该数为正数
- OF（Overflow Flag）溢出标志，若运算结果超出了机器表示的范围，运算结果错误，OF=1，否则OF=0
- AF（Auxiliary Flag）辅助进位标志，在8位加减运算中，若低4位向高4位有进位或借位，就使AF=1，否则AF=0
- PF（Parity Flag）奇偶校验标志，若本次运算结果低8位有偶数个1（如01101010B），则PF=1，否则PF=0

控制标志:

- TF
- DF
- IF

## 寻址方式和指令系统

### **基本概念**

1. 指令：单个的CPU操作，通知CPU执行某种操作的“命令”

   指令集：所有指令的集合

   机器指令：用二进制序列（0、1）代码书写。硬件只能识别、存储和运行机器指令

   符号指令：用字符串形式的序列（包含字符串形式的操作码、操作数）

2. 指令的组成： 操作码+操作数

   指令长度：机器指令长度为1~16字节

   指令地址：多字节指令会占用连续的内存单元，存放指令第一个字节的内存地址

3. 操作数：指令的操作对象（输入数据、输出数据）>可存放于 CPU寄存器、计算机的存储器、接口电路中的端口中

   - 寄存器操作数：存放于通用寄存器（8个）
   - 段寄存器和程序指针： CS:IP决定取哪条指令   
   - 标志存储器分： 状态标志、控制标志 

**状态标志：**

- C：最高位产生 借位或进位标志。进位C=1
- O：溢出标志。溢出O=1
- Z：零标志。结果为0则Z=1
- S：符号标志。就是结果的符号位。
- P：奇偶标志。低8位中1的个数为偶数P=1
- A：辅助进位标志。低半字节向高半字节有进位或借位，A=1

**控制标志：**

- D：方向标志。D=1时串操作时自动减量
- I：中断标志。I=1时允许CPU接收外部的中断请求
- T：陷阱标志。T=1时进入单步调试状态。

### 寻址方式

**操作数的存在方式（4种）：**

1. 立即数：包含在指令中------------立即寻址
2. 寄存器操作数：存放于CPU的某个寄存器中----------------寄存器寻址
3. 内存操作数：存放于存储器中------------------存储器寻址
4. I/O端口操作数：存放于I/O端口中

**寻址方式：**

- **立即寻址方式**

  立即数只能作源操作数，不能作目的操作数

  MOV AL, OFFSET BUF

  MOV CX, 0A234H（ A~F开头的数字，加上0作为前缀）

- **寄存器寻址方式**

  操作数包含在寄存器中，由指令指定寄存器的名称

  注意：源操作数的长度必须与目的操作数一致，比如不能把AH的内容传送到CX中

  MOV AX, BX

  INC SI

- **存储器寻址方式**

  存储器寻址（内存操作数寻址）： 5种   

  将指令中的逻辑地址（段寄存器名称 ： 偏移地址表达式）转化为对应的物理地址，再通过总线系统访问实际的物理存储单元（操作数的物理地址=段基址*16+偏移地址）。

  段寄存器名称：存放操作数的存储单元所在的逻辑段：如CS、DS、SS、ES。

  16位偏移地址表达式，给出偏移地址，是相对于逻辑段段首单元的地址偏移量

  - **直接寻址方式**

    物理地址=16*DS+EA，默认为DS为基地址，EA上必须加方括号，与立即数区分

    （段超越前缀）ES:[500H]，以ES作基地址

    ADD AL,DS:[45H]     ;   这里段寄存器名称一定要加

    MOV AX,ES:[1000H]

    MOV AX,DS:BUF 也可以写成 MOV AX,BUF

    INC BUF+2

    可以用变量名代替数值地址，实际上就是给存储单元起一个名字，变量名在汇编的时候，会给出实际的偏移地址，所以BUF+2,BUF都是直接寻址

  - **寄存器间接寻址方式**

    源操作数的寄存器的值为操作数的有效地址，寄存器名称外必须加方括号

    如果指令中指定的寄存器为BX、SI、DI，段地址为数据段DS

    如果为BP，段地址为堆栈段SS

    MOV BX，[SI]	物理地址=16*DS+SI

    允许段超越前缀

    只有一些指定的通用寄存器可作为间址寄存器使用：BX,SI,DI,BP

  - **寄存器相对寻址方式**

    与寄存器间接寻址类似，就是在有效地址上加一个位移量

    MOV BX, COUNT[SI]，位移量COUNT	物理地址=16*DS+COUNT+SI

    也允许段超越前缀

    MOV DH, ES:ARRAY[SI]

  - **基址变址寻址方式**

    操作数的有效地址为一个基址寄存器（BX或BP）和一个变址寄存器（SI和DI）的内容之和

    MOV AX, [BX+SI]    物理地址=16*DS+BX+SI

    基址寄存器为BX时，段址寄存器为DS；基址寄存器为BP时，段寄存器为SS

  - **相对基址变址寻址方式**

    操作数的有效地址为一个基址寄存器（BX或BP）和一个变址寄存器（SI和DI）的内容，再加上指令中指定的8位或16为位移量之和。

    就是在基址变址寻址方式上加上位移量

    MOV AL,[BX+SI+2]

- **其他寻址方式**

  - 隐含寻址
  - I/O 端口寻址
  - 一条指令作几种寻址方式
  - 转移类指令寻址

**总结一下寻址方式：**

- BX、SI、DI 对应的一定是数据段，BP对应的一定是堆栈段，也就是说：如果是以BX,SI,DI为存储器寻址方式，则操作数在数据段DS中；如果以 BP为存储器寻址方式，则在SS段中
- SI、DI不能做基址寄存器。 [SI]是间址， [SI+3]是变址，[BX]是间址，[BX+3]是基址。
- [BX]、[SI]是间址
- [DX]是不对的，因为DX不能作为存储器寻址方式中的寄存器

### 8086 指令系统

#### 数据传送指令

- **MOV 传送指令**

  IP 寄存器不能用作源操作数或目的操作数

  立即数和CS 寄存器不能用作目的操作数

  MOV 指令不能在两个存储单元之间直接传送数据，也不能在两个段寄存器之间直接传送数据

  <img src="/images/%E5%BE%AE%E6%9C%BA/image-20210623150746004.png" alt="image-20210623150746004" style="zoom:67%;" />

- **PUSH 进栈指令**

  PUSH 源	将源操作数推入堆栈，同时栈指针SP值减2

  源操作数可以是16位通用寄存器、段寄存器或存储器中的数据字，但不能是立即数

- **POP 出栈指令**

  POP 目的	将当前SP所指向的堆栈顶部的一个字送到指定的目的操作数中，同时栈指针SP值加2

  源操作数可以是16位通用寄存器、段寄存器或存储单元，但CS不能用作目的操作数

- **XCHG 交换指令**

  XCHG 目的， 源     把源操作数和目的操作数相交换

  交换可以在寄存器之间、寄存器和存储器之间，但段寄存器不能作为操作数，也不能直接交换两个存储单元之间的内容

- **XLAT 表转换指令**

- **IN 输入指令**

- **OUT 输出指令**

- **LEA 取有效地址指令**

  LEA 目的， 源

  取源操作数地址的偏移量，并把它传送目的操作数所在单位

  源操作数必须是存储单元，而且目的操作数必须是一个除段寄存器之外的16位寄存器

  注意与 MOV 指令的区别，MOV 指令传送的一般是源操作数中的内容而不是地址

- **LDS 将双字指针送到寄存器和DS指令**

  LDS 目的， 源

  从源操作数指定的存储单元中，取出一个变量的4字节地址指针，送进一对目的寄存器

  指令中源操作数必须是存储单元，从该存储单元开始的连续4个字节单元 中，存放着一个变量的地址指针。目的操作数必须是16位寄存器，通常使用SI寄存器，但是不能使用段寄存器

- **LES将双字指针送到寄存器和ES指令**

  LES 目的， 源

  与LDS指令操作基本相同，不同是将源操作数所指向的地址指针中的段地址部分送到ES寄存器中，而不是DS寄存器，目的操作数常用DI寄存器

- **LAHF 标志送到 AH 指令**

  把标志寄存器SF、ZF、AF、PF和CF分别传送到AH寄存器位7，6，4，2和0

- **SAHF AH送标志寄存器**

  把AH内容存入标志寄存器

- **PUSHF 标志入栈指令**

  把整个标志寄存器FLAGS的内容推入堆栈，同时栈指针SP值减2

- **POPF 标志出栈指令**

  把当前堆栈指针SP所指的一个字，传送到标志寄存器FLAGS，同时栈指针SP值加2

#### 算术运算指令

- **ADD 加法指令**

  ADD 目的，源	将源和目的操作数相加，结果送到目的操作数

- **ADC 带进位的加法指令**

  ADC 目的，源

  在两个操作数相加的同时，还要把进位标志CF的当前值加进去作为和，再把结果送到目的操作数中

- **INC 增量指令**

  INC 目的

  对目的操作数加一

- **AAA 加法的ASCII调整指令**

- **DAA 加法的ASCII调整指令**

  将两个压缩 BCD 数相加后的结果调整为正确的压缩 BCD 数。相加后的结果必须在 AL 中，才能使用 DAA 指令

- **SUB 减法指令**

  SUB  目的，源	将目的操作数减去源操作数，结果送到目的操作数

- **SBB 带借位的减法指令**

  SBB  目的，源	将目的操作数减去源操作数，还要减去进位/借位标志CF的值，结果送到目的操作数

- **NEG 取负指令**

- **CMP 比较指令**

  将目的操作数减去源操作数，但仅将结果反映在标志位上

- **AAS 减法的ASCII调整指令**

- **DAS 减法的十进制调整指令**

- **MUL 无符号数乘法指令**

  MUL 源

  把源操作数和累加器中的数都当成无符号数，然后将两数相乘，源操作数可以是字节或字

  如果源操作数是一个字节，则 AX <- AL * 源

  若源操作数是一个字，则 (DX，AX) <- AX * 源

  源操作数可以是寄存器或存储单元，不能是立即数

- **IMUL 整数乘法指令**

  IMUL  源

  把源操作数和累加器中的数，都作为带符号数，进行相乘

- **AAM 乘法的ASCII调整指令**

- **DIV 无符号数除法指令**

  DIV  源

  对两个无符号二进制数进行除法操作

  如果源操作数为字节，16位被除数必须放在AX中，并且有：

  AL  <- AX / 源(字节)的商

  AH <- AX / 源(字节)的余数

  (要是被除数只有8位，必须把它放在AL中，并将AH清0，然后相除)

  

  如果源操作数为字，32位被除数必须放在DX、AX中，并且有：

  AX  <- (DX，AX) / 源(字)的商

  DX <- (DX，AX)/ 源(字)的余数

  (要是被除数只有16位，除数也是16位，必须把16位被除数放在AX中，并将DX清0，然后相除)

- **IDIV 整数除法指令**

  功能与DIV相同，但操作数都必须是带符号数，商和余数也都是带符号数，而且规定余数的符号和被除数的符号相同

- **CBW 把字节转换为字指令**

  将寄存器AL中字节的符号位扩充到AH的所有位

- **CWD 把字转换成双字指令**

  把AX中的字的符号位扩充到DX寄存器的所有位中去

- **AAD 除法的ASCII调整指令**

#### 逻辑运算和移位指令

- **NOT取反指令**

  将目的操作数求反

  目的操作数可以是8位或16位寄存器或存储器，指令执行后，对标志位无影响

- **AND 逻辑与指令**

  对两个操作数进行按位逻辑与操作，结果返回目的操作数

- **OR 逻辑或指令**

  对两个操作数进行按位逻辑或操作，结果返回目的操作数

- **XOR 异或操作指令**

  对两个操作数进行按位逻辑异或运算，结果返回目的操作数

- **TEST 测试指令**

  对两个操作数进行按位逻辑与操作，并修改标志位，但不回送结果

- **SAL 算术左移指令**

- **SHL 逻辑左移指令**

  上面两条指令的功能完全相同，均将寄存器或存储器中的目的操作数的各位左移，每移动一次，最低有效位LSB补0，最高有效位MSB进入标志位CF

- **SHR 逻辑右移指令**

  均将寄存器或存储器中的目的操作数的各位右移，每移动一次，最高位补0，最低位进入标志位CF

- **SAR 算数右移指令**

  目的操作数的各位右移，每移动一次，最低位进入标志位CF，但最高位（符号位）保持不变（即与之前最高位保持一致

- **ROL 循环左移指令**

- **ROR 循环右移指令**

- **RCL 通过进位位循环左移指令**

- **RCR 通过进位位循环右移指令**

  目的操作数可以是8/16位的寄存器操作数或内存操作数，计数值含义同上，即1或由C指定。

  ROL和ROR为小循环移位指令，没有把CF包含在循环中；RCL和RCR为大循环指令，把CF作为整个循环的一部分参加循环移位。

  CF的值由最后一次被移出的值决定。OF的值只有在移动1次的指令中才有效，移位后符号位发生变换，则OF置1，否则OF置0

  ```
  设 CF=1，AL=1011 0100B
  若执行指令 ROL  AL，1
      则 AL=0110 1001B，CF=1，OF=1；
  若执行指令 ROR  AL，1
      则 AL=0101 1010B，CF=0，OF=1；
  若执行指令 RCR  AL，1
      则 AL=1101 1010B，CF=0，OF=0；
  若执行指令 MOV  CL，3 和 RCL  AL，CL
      则 AL=1010 0110B，CF=1，OF不确定。
  ```
  
  注意，在移位操作中，移位次数为多次时，必须将移位次数存放到**CL寄存器**中

#### 字符串处理指令

- **MOVS 字符串传送指令**

  MOVS 目的串， 源串

  把由SI作指针的源串中的一个字节或字，传送到由DI作指针的目的串中，且自动修改指针SI和DI

  REP MOVSB 等价于

  MOVS NEW_LOC, SRC_MESS

  ​			DEC CX

  ​			 JNZ AGAIN

- **CMPS 字符串比较指令**

- **SCAS 字符串扫描指令**

- **LODS 数据串装入指令**

- **STOS 数据串存储指令**

  将累加器AL或AX中的一个字节或字，传送到附加段中以DI为目标指针的目的串中，同时修改DI，以指向串中的下一个单元

#### 控制转移指令

- **JMP 无条件转移指令**

  使程序无条件的转移到指令中的目的地址去执行

- **过程调用和返回指令**

  CALL 过程名

  RET

- **直接标志转移指令**

  | 指令助记符 | 测试条件 | 指令功能       |
  | ---------- | -------- | -------------- |
  | JC         | CF=1     | 有进位         |
  | JNC        | CF=0     | 无进位         |
  | JZ/JE      | ZF=1     | 结果为零/相等  |
  | JNZ/JNE    | ZF=0     | 不为零/相等    |
  | JS         | SF=1     | 符号为负       |
  | JNS        | SF=0     | 符号为正       |
  | JO         | OF=1     | 溢出           |
  | JNO        | OF=0     | 无溢出         |
  | JP/JPE     | PF=1     | 奇偶位为1/为偶 |
  | JNP/JPO    | PF=0     | 奇偶位为0/为奇 |

- **间接标志条件转移指令**

  **无符号数**

  JA/JNBE	高于/不低于等于

  JAE/JNE	高于等于/不低于

  JB/JNAE	低于/不高于等于

  JBE/JNA	低于等于/不高于

  **带符号数**

  JG/JNLE	大于/不小于等于

  JGE/JNL	大于等于/不小于

  JL/JNGE	小于/不大于等于

  JLE/JNG	小于等于/不大于

- **LOOP 循环指令**

- **LOOPE/LOOPZ 相等或结果为0时循环**

- **LOOPNE/LOOPNZ 相等或结果为不0时循环**

- **INT n 软件中断指令**

- **INTO 溢出中断指令**

- **IRET 中断返回指令**

#### 处理器控制指令

- CLC,CMC,STC
- CLD,STD
- CLI,STI
- HLT 停机指令
- NOP 空指令或无操作指令

## 汇编语言程序设计

### 汇编语言程序结构

1.处理器选择伪指令

2.段定义伪指令 （ SEGMENT   ENDS为定界语句）

3.段约定伪指令

4.汇编结束伪指令

END 程序启动指令标号

汇编程序对END之后额语句将不再进行任何处理。DOS装载程序的可执行文件是，自动把标号所在段的段基址赋给CS，把标号所在单元的偏移地址赋给IP

5.DOS的返回

程序完成预定任务之后，必须返回DOS

返回DOS的3种方法：P27

第一种：    MOV AH,4CH

INT 21H

第二种： INT 20H

第三种：MAIN PROC FAR

​           PUSH DS

​           SUB AX,AX

​           PUSH AX

​           …..

​           RET

​           MAIN ENDP

### 汇编源程序的编程格式

（1）exe文件

exe文件允许使用多个逻辑段，每个逻辑段不超过64KB，适合编写大型程序。

（2）com文件

com文件只允许使用一个逻辑段，即代码段。程序所使用的数据，可以集中设置在代码段的开始或末尾。需要使用ORG定位伪指令将程序的启动指令存放在代码段偏移地址为100H的单元。

ORG指令用于通知汇编程序，将下一条指令或数据存放在表达式给出的段内实际偏移地址。

DATA SEGMENT AT 0040H

   ORG 0017H

KEYFLAG DB ?

DATA ENDS

定义了KEYFLAG变量，存放在段基址为40H，偏移地址为0017H的内存单元中。

### DOS功能调用

**1、调用模式：**

MOV AH,功能号

如果有入口参数，设置入口参数

INT 21H

如果有出口参数，分析出口情况

**2、功能号**

- 01H号功能读字符，出口参数 AL=输入字符

- 02H号功能显示字符；入口参数 DL=显示字符的 ASCII 码
- 09H显示以 $ 结尾的字符串，入口参数 DS:DX=字符串首地址

- 0AH键盘输入字符串，从BUF+2单元开始存放，入口参数 DS:DX=字符串首地址

- 4CH功能返回DOS（返回DOS的操作系统），即程序终止

### 程序设计

	在循环程序中，常用计数器CX寄存器控制循环次数，每经过一次循环操作，计数器自动减1，减到0时，表示循环结束
			LEA BX,DATA		;DATA偏移地址送BX
			MOV CX,14		;设循环次数
			MOV AL,[BX]		;第一个带符号数送AL
	CHECK:  INC BX
			CMP AL,[BX]		;两数比较
			JNZ DONE		;如果AL中的数较小，则转DONE
			MOV AL,[BX]
	DONE:	LOOP CHECK		;循环次数，CX=CX-1，当CX==0，结束循环，执行后续语句
			MOV MIN,AL		;存放最小数
			HLT
# 复习题

## 书后习题

1. **两个带符号数 1011 0100B 和 1100 0111B 相加,运算后各标志位的值等于多少?哪些标志位是有意 义的?如果把这两个数当成无符号数,相加后哪些标志位是有意义的?**

   答：

   **带符号数：**

   1 0111 1011

   CF=1，有进位，对于带符号数，无意义

   PF=1，结果有偶数个1

   AF=0，无半进位，非BCD码运算，无意义

   ZF=0，结果非0

   SF=0，结果为正数

   OF=1，溢出（两个负数相加，结果为正数）

   **无符号数：**

   1 0111 1011

   CF=1，有进位

   PF=1，结果有偶数个1

   ZF=0，结果非0

   AF、SF、OF无意义

2. **如果从存储单元 2000H 开始存放的字节数据为:3AH,28H,56H,4FH，试画出示意图说明:从 2000H 到 2001H 单元开始取出一个字数据各要进行几次操作,取出的数据分别等于多少。**

   答：

   (2000H)=3AH,(2001H)=28H,(2002H)=56H,(2003H)=4FH，从 2000H 取一个字要 1 次操作，数据为 283AH；从 2001H 取一个字要2次操作，数据为 5628H

3. **分别说明下列指令的源操作数和目的操作数各采用什么寻址方式。**

   （1）MOV AX，2408H 

   （2）MOV CL，0FFH 

   （3）MOV BX，[SI] 

   （4）MOV 5[BX]，BL 

   （5）MOV [BP+100H]，AX 

   （6）MOV [BX+DI]，’$’

   （7）MOV DX，ES：[BX+SI] 

   （8）MOV VAL[BP+DI]，DX 

   （9）IN AL，05H 

   （10）MOV DS，AX

   答：

   （1）立即数，寄存器 

   （2）立即数，寄存器 

   （3）寄存器间接，寄存器 

   （4）寄存器，寄存器相对 

   （5）寄存器，寄存器相对 

   （6）立即数，基址变址

   （7）基址变址，寄存器 

   （8）寄存器，相对基址变址 

   （9）直接端口寻址，寄存器 

   （10）寄存器，寄存器

4. **已知：DS=1000H，BX=0200H，SI=02H，内存10200H～10205H 单元的内容分别为10H， 2AH，3CH，46H，59H，6BH。下列每条指令执行完后AX 寄存器的内容各是什么？** 

   （1）MOV AX，0200H 

   （2）MOV AX，[200H] 

   （3）MOV AX，BX 

   （4）MOV AX，3[BX] 

   （5）MOV AX，[BX+SI] 

   （6）MOV AX，2[BX+SI]

   答：

   （1）0200H

   （2）2A10H

   （3）0200H 

   （4）5946H

   （5）46C3H

   （6）6B59H

5. **指出下列指令中哪些是错误的，错在什么地方。** 

   （1）MOV DL，AX 

   （2）MOV 8650H，AX 

   （3）MOV DS，0200H 

   （4）MOV [BX]，[1200H]

   （5）MOV IP，0FFH 

   （6）MOV [BX+SI+3]，IP 

   （7）MOV AX，[BX] [BP] 

   （8）MOV AL，ES：[BP] 

   （9）MOV DL，[SI] [DI] 

   （10）MOV AX，OFFSET 0A20H 

   （11）MOV AL，OFFSET TABLE 

   （12）XCHG AL，50H 

   （13）IN BL，05H 

   （14）OUT AL，0FFEH

   答：

   （1）长度不匹配 

   （2）立即数不能做目的操作数

   （3）段寄存器不能用立即数赋值

   （4）不能两个内存（目的数和源操作数不能同时为存储单元）

   （5）IP 不能用指令直接修改

   （6）指令中不能出现 IP

   （7）BX/BP 应与 SI/DI 搭配

   （8）对

   （9）SI/DI 应与 BX/BP 搭配

   （10）OFFSET 后应该跟内存

   （11）应该用 AX

   （12）不能立即数

   （13）IN 必须用 AL/AX

   （14）操作数反：地址应为8位

6. **已知当前 SS=1050H,SP=0100H,AX=4860H, BX=1287H,试用示意图表示执行下列指 令过程中,堆栈中的内容和堆栈指针 SP 是怎样变化的**

   PUSH AX
   PUSH BX
   POP BX
   POP AX

   <img src="/images/%E5%BE%AE%E6%9C%BA/image-20210623103703224.png" alt="image-20210623103703224" style="zoom:67%;" />

7. **下列指令完成什么功能?** 

   (1)ADD AL,DH

   (2)ADC BX,CX

   (3)SUB AX,2710H

   (4)DEC BX

   (5)NEG CX

   (6)INC BL

   (7)MUL BX

   (8)DIV CL

   答：

   (1) AL+DH->AL

   (2) BX+CX+CF->BX

   (3) AX-2710H->AX

   (4) BX-1->BX

   (5) 0-CX->CX

   (6) BL+1->BL

   (7) AX*BX->DX

   (8) AX/CL

## 题一

1. **寻址方式？**

   寄存器间接寻址、直接寻址、寄存器相对寻址、基址加变址寻址、基址加变址相对寻址。

2. **数据操作数的种类？**

   立即数、寄存器数和内存单元数

3. **段地址、偏移地址与物理地址之间的关系？有效地址EA又是指什么？**

   段地址左移四位加上偏移地址形成20位的物理地址。EA是指段内偏移地址，即表示段内某单元相对于段起始地址的空间位置。

4. **能用于寄存器间接寻址及变址寻址的寄存器有哪些？它们通常与哪个段寄存器配合形成物理地址？**

   基址寄存器 BX 和 BP，变址寄存器 SI 和 DI

   BX、SI、DI与DS配合形成物理地址，而BP与SS配合形成物理地址。

5. **什么是堆栈操作？以下关于堆栈操作的指令执行后，SP的值变化是多少？**

   PUSH AX

   PUSH CX

   PUSH DX

   POP AX

   PUSH BX

   POP CX

   POP DX

   堆栈被定义为一种先进后出的数据结构，即最后进栈的元素将被最先弹出来。堆栈从一个称为栈底的位置开始，数据进入堆栈的操作称为压入（或压栈），数据退出堆栈的操作称为弹出，每进行一次弹出操作，堆栈就减少一个元素，最后一次压入的元素，称为栈顶元素，压入弹出操作都是对栈顶元素进行的堆栈的两种基本的操作。

   在进行以上一系列堆栈操作后，SP指针的值是原 SP-2。

6. **用汇编语言指令实现以下操作**

   **(1)将寄存器AX、BX和DX的内容相加，和放在寄存器DX中。**

   ADD AX，BX

   ADD DX，AX

   **(2)用基址变址寻址方式（BX和SI）实现AL寄存器的内容和存储器单元BUF中的一个字节相加的操作，和放到AL中。**

   ADD AL，BYTE PTR [BX] [SI]

   BYTE PTR[DI] 表示指向的值是个BYTE （一字节）

   **(3)用寄存器BX实现寄存器相对寻址方式（位移量为100H），将DX的内容和存储单元中的一个字相加，和放到存储单元中。**

   ADD 100H[BX]，DX

   **(4)用直接寻址方式（地址为0500H）实现将存储器中的一个字与立即数3ABCH相加，和放回该存储单元中。**

   ADD [0500H]，3ABCH

   **(5)用串操作指令实现将内存定义好的两个字节串BUF1和BUF2相加后的和，存放到另一个串BUF3中的功能。**

   ```
   ……
   MOV CX, COUNT
   MOV SI, OFFSET BUF1
   MOV DI, OFFSET BUF3
   MOV BX, OFFSET BUF2
   AGAIN: LODSB ;取[DS]:SI中的字节
   ADD AL, [BX] ;与[DS]:BX中的字节相加
   STOSB     ;存入[ES]:DI中
   INC BX
   DEC CX
   JNZ AGAIN
   ……
   ```

7. **指出下列指令中，源操作数及目的操作数的寻址方式。**

   SUB BX，[BP+35]  ；寄存器寻址、寄存器相对寻址

   MOV AX，2030H  ；寄存器寻址、立即寻址

   SCASB        ；隐含操作数为寄存器寻址和寄存器间接寻址

   IN AL，40H     ；寄存器寻址、立即寻址

   MOV [DI+BX]，AX  ；基址加变址寻址、寄存器寻址

   ADD AX，50H[DI]  ；寄存器寻址、寄存器相对寻址

   MOV AL，[1300H]  ；寄存器寻址、直接寻址

   MUL BL       ；寄存器寻址、目的操作数为隐含寄存器寻址

8. **已知（DS）= 1000H，（SI）= 0200H，（BX）= 0100H，（10100H）= 11H，（10101H）= 22H，（10600H）= 33H，（10601H）= 44H，（10300H）= 55H，（10301H）= 66H，（10302H）= 77H，（10303H）= 88H，试分析下列各条指令执行完后AX寄存器的内容。**

   ```
   MOV AX，2500H     （AX）=2500H
   MOV AX，500H[BX]   （AX）==4433H
   MOV AX，[300H]     （AX）=6655H
   MOV AX，[BX]      （AX）=2211H
   MOV AX，[BX][SI]    （AX）=6655H
   MOV AX，[BX+SI+2]   （AX）=8877H
   ```

9. 判断下列指令是否有错，如果有错，说明理由。 

   | SUB BL，BX               | 两个操作数的宽度不一样                     |
   | ------------------------ | ------------------------------------------ |
   | MOV [DI]，[SI]           | 两个操作数不能同时为内存数                 |
   | MOV AX，BYTE PTR[SI]     | 源操作数限定为字节，与目的操作数宽度不一致 |
   | MOV 125，CL              | 立即数不能做目的操作数                     |
   | MOV CS，BX               | 不能对CS实现传送操作                       |
   | SHR AX，4                | 只有当移位位数为1时，才能用立即数表达      |
   | MOV AH，[SI] [DI]        | 不能用两个变址寄存器来实现寻址操作         |
   | SHL AX，CH               | 移位指令的移位位数用CL给出，不能用CH。     |
   | MOV  BYTE PTR[BX]，3456H | 将16位的立即数传送到一个字节的内存单元     |

10. **设（DS）= 1000H，（ES）= 2000H，（SS）= 3000H，（SI）= 0080H，（BX）= 02D0H，（BP）= 0060H，试指出下列指令的源操作数字段是什么寻址方式？它的物理地址是多少？**

    ```
    MOV AX，0CBH 立即寻址
    MOV AX，[100H] 直接寻址，物理地址为：10100H
    MOV AX，[BX] 寄存器间接寻址，物理地址为：102D0H
    MOV AX，[BP] 寄存器间接寻址，物理地址为：20060H
    MOV AX，[BP+50] 寄存器相对寻址，物理地址为：200B0H
    MOV AX，[BX][SI] 基址加变址寻址，物理地址为：10350H
    ```

11. **分别说明下列每组指令中的两条指令的区别.**

    **（1） AND CL，0FH 按位相“与”，高4位为“0000”，低4位保留原值；**

    OR CL，0FH 按位相“或”，高4位为原值，低4位为“1111”。

    **（2） MOV AX，BX  将BX寄存器的内容传送到AX寄存器中；**

    MOV AX，[BX] 将BX寄存器所指的内存单元的内容送AX寄存器中。

    **（3） SUB BX，CX  BX寄存器内容减去CX寄存器的内容，结果送回到BX；**

    CMP BX，CX  BX内容减去CX内容，结果只影响标志位。

    **（4） AND AL，01H AL内容与01H相“与”，结果为“0000000x”送回AL寄存器；**

    TEST AL，01H AL内容与01H相“与”，结果只影响标志位（ZF）。

    **（5） JMP NEAR PTR NEXT NEXT所指指令在当前指令的同段内；**

    JMP SHORT NEXT NEXT所指指令在当前指令的8位地址范围内。

    **（6） ROL AX，CL 循环左移，进位标志位不参与循环；**

    RCL AX，CL 循环左移，进位标志位参与循环。

    **（7） PUSH AX 将AX内容存入栈顶指针处，即进栈操作；**

    POP AX 将栈顶内容弹出装入AX寄存器中，即出栈操作。

12. **试分析以下程序段执行完后BX的内容为何？**

    MOV BX，1030H

    MOV CL，3

    SHL BX，CL  逻辑左移，BX= 1000 0001 1000 0000 = 8180H

    DEC BX  减一

    程序执行完后，**BX=817FH**

13. **编写能实现以下功能的程序段。**

    **根据CL中的内容决定程序的走向，设所有的转移都是短程转移。若D0位等于1，其他位为0，转向LAB1；若D1位等于1，其他位为0，转向LAB2；若D2位等于1，其他位为0，转向LAB3；若D0、D1、D2位都是1，则顺序执行。**

    ```
    ……
    AND CL，07H
    CMP CL，01H
    JZ LAB1
    CMP CL，02H
    JZ LAB2
    CMP CL，04H
    JZ LAB3
    CMP CL，07H
    JNZ OVER
    ……
    LAB1： ……
    LAB2： ……
    LAB3： ……
    OVER：……
    ```

14. 写出下列指令序列中每条指令的执行结果，并在DEBUG环境下验证，注意各标志位的变化情况。

    MOV BX，126BH	(BX=126BH)

    ADD BL，02AH	(BX=1295H)

    MOV AX，2EA5H	(AX=2EA5H)

    ADD BH，AL	(BX=B795H)

    SBB BX，AX	(BX=88F0H)

    ADC AX，26H	(AX=2ECBH)

    SUB BH，-8	(BX=90F0H)

15. **程序段1:**

    MOV AX,4455H

    MOV BX,7722H

    PUSH AX

    POP CX

    XCHG BX, CX

    程序执行后 **AX = 4455H, BX = 4455H， CX = 7722H**.

16. **程序段2：**

    MOV AX, 8765H

    MOV DX,4321H

    MOV CL，04

    SHL DX，CL	(DX=3210H)

    MOV BL，AH	(BL=87H)

    SHL AX，CL	(AX=0111 0110 0101 0000=7650H)

    SHR BL，CL	(BL=08H)

    OR DL，BL	(DL=18H)

    程序执行后 **AX= 7650H,  DX= 3218H** 

17. **程序段3：**

    TABLE    DW 11H，2233H，4455H，6677H，88H

    ​       …

    ​       MOV BX, OFFSET TABLE

    ​       MOV AX, [BX]

    ​       MOV DX, [BX+3]

    程序执行后，**AX = 0011H, DX= 5522H**

    ```
    0000:11	BX
    0001:00
    0002:33
    0003:22	BX+3
    0004:55
    0005:44
    0006:77
    0007:66
    0008:88
    0009:00
    ```


## 题二

1. **设BX=0123H，DI=1000H，DS=3200H，试指出下列各条指令中源操作数的寻址方式，对于是存储器操作数的，还需写出其操作数的有效地址和物理地址。**

   （1）MOV AX,[2A38H]

   （2）MOV AX,[BX]

   （3）MOV AX,[BX+38H]

   （4）MOV AX,[BX+DI]

   （5）MOV AX,[BX+DI+38H]

   （6）MOV AX,2A38H

   （7）MOV  AX,BX

   参考答案：

   （1）直接寻址 有效地址=2A38H，物理地址=32000H+2A38H=34A38H

   （2）寄存器间接寻址 有效地址=0123H，物理地址=32000H+0123H=32123H

   （3）寄存器相对寻址 有效地址=0123H+38H=015BH，物理地址=32000H+015B=3215BH

   （4）基址变址寻址  有效地址=0123H+1000H=1123H，物理地址=32000H+1123H=33123H

   （5）相对基址变址寻址 有效地址=0123H+1000H+38H=115BH，物理地址=32000H+115BH=3315BH

   （6）立即寻址    

   （7）寄存器寻址

2. **设AX=96BCH，BX=AC4DH，CF=0。求分别执行指令ADD AX,BX和SUB AX,BX后，AX与BX的值各为多少？并指出标志位SF、ZF、OF、CF、PF、AF的状态。**

   参考答案：

   执行ADD AX,BX后，AX=4309H，BX= AC4DH ，SF=0 ZF=0 OF=1 CF=1 PF=1 AF=1 

   执行SUB AX,BX后，AX=EA6FH，BX= AC4DH ，SF=1 ZF=0 OF=0 CF=1 PF=1 AF=1

3. **采用三种不同的方法实现AX与DX的内容交换**

   参考答案：

   第一种：XCHG AX，DX （XCHG 把源操作数和目的操作数相交换）

   第二种：PUSH AX

   ​    			PUSH DX

   ​    			POP AX

   ​    			POP DX

   第三种：MOV BX，AX

   ​    			MOV AX，DX

   ​    			MOV DX，BX

4. **编写程序段实现：当DL中存放的数据是奇数时使AL=1，否则使AL=-1**

   参考答案：

   ```
       TEST DL,01H （逻辑与操作，但不回送结果，检查DL的最低位是否为1）
       JNZ  NEXT	（为1，说明是奇数，转NEXT）
       MOV AL,-1
       JMP EXIT
   NEXT:MOV AL,1 
   EXIT:  
   ```

5. **用尽可能少的指令实现使DL中的高4位内容与低4位内容互换**

   参考答案：

   MOV CL，4

   ROL DL，CL  或 ROR DL，CL

6. **编写程序段，判断AL中的带符号数是不是负数。若是负数，则将-1送给AH；否则，将1送给AH**

   参考答案：

   ```
       SUB AL,0
       JS negn （符号为负 转移）
       MOV AH,1
       JMP post
   negn: MOV AH,-1
   Post:  
   ```

7. **假设DX=87B5H，CL=4，CF=0，确定下列各条指令单独执行后DX中的值**

   （1）SHL DL,1

   （2）SHR DX,CL

   （3）SAR DX, CL

   （4）ROL DX,CL

   （5）ROR DX,CL

   （6）RCL DX,CL

   （7）RCR DX,1

   参考答案：

   （1）DX=876AH 

   （2）DX=087BH

   （3）DX=F87BH

   （4）DX=7B58H

   （5）DX=587BH

   （6）DX=7B54H

   （7）DX=43DAH

8. **按下列要求编写指令序列。**

   （1）将AX中的低4位置1，高4位取反，其它位清0。

   （2）检查DX中的第1、6、11位是否同时为1。

   （3）清除AH中最低3位而不改变其它位，将结果存入BH中。

   参考答案：

   （1）XOR AX,F000H	//异或取反

   ​	      AND AX,F00FH	//其他位清零

   ​          OR AX,000FH	//低四位置1

   （2）MOV AX,DX

   ​          AND DX,0842H	//(0000 0100 0010 0010 最右端那一位为b0,最高位是b15，第1、6、11位为b1,b6,b11)

   ​          XOR DX,0842H      

   ​          JZ ZERO

   ​          …  

   ​         ZERO: …       DX中的第1、6、11位同时为1的情况

   ​          …  

   （3）AND DH,0F80H

   ​		  MOV BH,DH

9. **分析下面的程序段完成什么功能？（提示：请将DX与AX中的内容作为一个整体来考虑）**

   MOV  CL, 04       （将4存入CL中）  

   SHL  DX, CL	    （DX逻辑左移4位，DX最低4位为0）

   MOV  BL, AH      （将AH中内容存入BL，以免AX左移4位时高4位丢失）

   SHL  AX, CL         （AX逻辑左移4位）

   SHR BL, CL          （BL逻辑右移4位，这样AX原来的最高4位就放到BL的低4位了）

   OR  DL, BL          （DL与BL按位逻辑或操作，结果返回DL，也就是把AX原来的最高四位写入到DX的最低四位）

   参考答案：DX和AX中联合存放一个32位的二进制数（DX存放高16位），这个程序段把它逻辑左移4位。

10. **设SS=1000H，SP=2000H，AX=345AH，BX=F971H，Flags=4509H，试分析执行以下指令**

    PUSH BX

    PUSH AX

    PUSHF	（将标志寄存器Flags的值压入堆栈顶部, 同时栈指针SP值减2）

    POP CX

    **之后，SP、SS、CX的值各为多少？**

    参考答案：SP=1FFCH  SS=1000H  CX=4509H

11. **指出下列指令中哪些是错误的，并说明错误原因**

    ```
    （1）MOV DL,CX           （2）MOV DS,1000H
    （3）MOV [DI],[BX]       （4）MOV DL,[BX][BP]
    （5）XCHG AX,[5000H]     （6）PUSH 3541H
    （7）INC [BX]            （8）POP CS
    （9）MOV A[BX+SI],0      （10）MOV AL,300
    ```

    参考答案：

    （1）数据类型不匹配       （2）立即数不能送段寄存器

    （3）两个存储器操作数之间不能直接传送数据

    （4）源操作数寻址不能为基址加基址

    （5）正确             （6）PUSH指令的操作数不能为立即数

    （7）存储器操作数类型不明确    （8）CS不能作为目的操作数使用

    （9）目的操作数类型需明确     （10）两个操作数数据类型不匹配

12. **已知各寄存器和存储单元的状态如图3.19所示，请阅读下列程序段，并将中间结果填入相应指令右边的空格**

    <img src="/images/%E5%BE%AE%E6%9C%BA/clip_image001.png" alt="img" style="zoom:75%;" />

    ```
    MOV  DX,[BX+4]                          ; DX=（ 1A87H ）
    PUSH  DS                                ; SP=（ FFFEH ） 
    TEST  AX,DX                             ; AX=（ 8E9DH ）  SF=（0 ）
    ADC  AL, [DI]                           ; AL=（ DBH ）
    XCHG  AX,DX                             ; AX=（ 1A87H ） DX=（8eDBH ） 
    XOR  AH,BL                              ; AH=（ 1EH ） 
    SAR  AH,1                               ; AH=（ 0FH ） CF=（0 ）
    ```

13. **假设以1000H为起始偏移地址的内存单元内容显示如图3.20所示，请指出在DEBUG下如下每条指令的寻址方式及执行后的结果**

    MOV  AX,1000  

    MOV BX,AX  

    MOV  AX,[BX] 

    MOV  AX,10[BX]

    <img src="/images/%E5%BE%AE%E6%9C%BA/clip_image002.jpg" alt="img" style="zoom:75%;" />

    参考答案：

    MOV  AX,1000        ；立即寻址，AX=1000H

    MOV BX,AX        ；寄存器寻址，BX=1000H

    MOV  AX,[BX]        ；寄存器间接寻址，AX=3412H

    MOV  AX,10[BX]       ；寄存器相对寻址，AX=8877H

14. **设AL=86H，BL=21H，在分别执行MUL和IMUL指令后，各自的结果是多少？OF=？，CF=？**

    参考答案：

    执行MUL BL后，结果AX=1146H；OF=1，CF=1

    执行IMUL BL后，结果AX=F046H；OF=1，CF=1

## 题三

1. **开发汇编语言源程序的主要步骤有哪些？**

   （1）问题定义

   （2）建立数学模型

   （3）确立算法和处理方案

   （4）画流程图

   （5）编制程序

   （6）上机调试

   （7）试运行和分析结果

   （8）整理资料，投入运行

2. **简述衡量一个程序质量的标准**

   1)    程序的正确性和完整性。

   2)    程序的易读性。

   3)    程序的执行时间和效率。

   4)    程序所占内存的大小。

3. **循环程序由几部分组成？各部分的功能是什么？**

   1)    循环初始化部分。这是循环准备工作阶段，如建立地址指针、设置循环次数、必要的数据保护以及为循环体正常工作而建立的初始状态等。这一部分本身只执行一次。

   2)    循环体。即循环程序要完成的具体操作，是需要重复执行的程序段。它是循环的核心部分，没有循环体就不能构成循环。

   3)    循环控制部分。循环控制部分主要用来结束整个循环过程，根据循环所给定的条件，判别循环是否结束，完成对循环的控制。

   4)    循环控制修改部分。这一部分是为保证每一次循环时，参加执行的信息能发生有规律的变化而建立的程序段。循环控制主要是一些运算控制单元（变量、寄存器）的修改间距、修改操作数地址、修改循环计数器、改变变量的值等。

4. **常用循环程序的控制方法由哪几种？阐述每种的特点**

   控制循环次数较常用的方法是用计数器控制循环、按问题的条件控制循环和用逻辑变量控制循环。

   计数器控制循环就是利用循环次数作为控制条件，它是最简单的和典型的循环控制方法。对于循环次数已知的程序，或者在进入循环前可由某个变量确定循环次数的程序，通常用计数器来控制循环。这种情况适于采用循环指令LOOP来实现循环功能。

   有些循环程序的循环次数事先无法确定，但它与问题的某些条件有关。这些条件可以通过指令来测试。若测试比较的结果满足循环条件，则继续循环，否则结束循环。这就是所谓的按问题的条件控制循环。事实上，利用条件转移指令支持的转移条件作为循环控制条件，可以更方便地构造复杂的循环程序结构。

   在有些情况下，可能在一个循环中有两个循环支路，在第一个支路循环了若干次以后，转至另一个循环支路循环。这就可以设置一个逻辑变量，用以控制转入不同的循环支路。具体实现方法是：把逻辑变量送入寄存器中，以逻辑变量各位的状态作为执行某段程序的标志。逻辑变量可由一到多个字节组成。

5. **在内存BUFFER单元中定义有10个16位数，试寻找其中的最大值及最小值，并放至指定的存储单元MAX和MIN中。画出程序流程图。**

   ```
   DATA SEGMENT
   		BUFFER DW 56H，29H，10H，22H，09H，8FH，1AH，6DH，3DH，33H
   		MAX DW ？
   		MIN DW ？
   DATA ENDS
   CODE SEGMENT
   		ASSUME CS：CODE，DS：DATA
   START：MOV AX，DATA
   		MOV DS，AX
   		MOV BX，OFFSET BUFFER
   		MOV CX，10
   		DEC CX
   		MOV AX，[BX]
   		INC BX
   LOP1：CMP AX，[BX]
   		JGE BIG
   		MOV AX，[BX]
   BIG：INC BX
   		LOOP LOP1
           MOV MAX，AX
           MOV BX，OFFSET BUFFER
           MOV CX，10
           DEC CX
           MOV AX，[BX]
           INC BX
   LOP2：CMP AX，[BX]
           JLE SMALL
           MOV AX，[BX]
   SMALL：INC BX
           LOOP LOP2
           MOV MIN，AX
   EXIT：MOV AH，4CH
   		INT 21H
   CODE ENDS
   		END START
   ```

6. **统计字型变量DATBUF中的值有多少位为0，多少位为1，并分别记入COUNT0及COUNT1单元中**

   编程思路：

   在内存单元定义一个变量DATBUF，将其取到寄存器中，采用移位的方式识别每一位为0还是为1，设置两个计数器分别统计。统计好后，分别存入内存单元。

   ```
   DATA SEGMENT
   DATBUF DW 2398H
   ZEROCOUNT DB 0
   ONECOUNT DB 0
   DATA EDNS
   CODE SEGMENT 
   	ASSUME CS:CODE, DS:DATA
   START:
   	MOV AX, DATA
   	MOV DS AX	
   	MOV BX, DATBUF
   	MOV CX,16
   	XOR AX  ；AL AH分别用来存放0的个数和1的个数
   NEXT:
       ROL BX,1
       JC APP1
       INC AL
       LOOP NEXT
       JMP EXIT
   APP1:
       INC AH
       LOOP NEXT
   EXIT:
       MOV ONECOUNT, AH
       MOV ZEROCOUNT, AL
       MOV AX,4C00H
       INT 21H
   CODE ENDS
   	END START
   ```

7. **设在变量单元A1、A2、A3、A4中存放有4个数，试编程实现将最大数保留，其余三个数清零的功能。**

   编程思路：

   依次比较各个数，每次比较将较小的数清零，较大数及较大数的地址保留，再继续与下一个数比较，直至四个数处理完。

   ```
   DATA SEGMENT
   A1 DW 123H
   A2 DW 345H
   A3 DW 321H
   A4 DW 098H
   DATA ENDS
   CODE SEGMENT
   ASSUME CS:CODE,DS:DATA
       MOV AX, DATA
       MOV DS, AX
       MOV AX, A1; AX中存放数
       LEA BX, A1 
       MOV SI, BX；SI中存放地址
       MOV CX, 3
       ADD BX, 2
   AGAIN:
       CMP AX, [BX]
       JGE NEXT1
       MOV [SI], 0
       MOV AX, [BX]； 替换成大的数
       MOV  SI, BX；保存大数的地址
       JMP AA
   NEXT1:
   	MOV [BX], 0
   AA：ADD BX, 2
   	LOOP AGAIN
   ```

8. **在BUFF开始的存储区中存放30个带符号数，试统计其正数、负数和零的个数。并将个数分别放至A1、A2及A3单元**

   编程思路：

   将30个符号数依次取到寄存器中，判断每个数的符号位，依此可识别出负数和非负数，再判断是否为0，可识别出是零还是正数。设置3个计数器分别统计正数、负数和零的个数，统计完后存入内存单元。

9. **若在内存缓冲区中存在一个无序列，列的长度放在缓冲区的第一个字节，试将内存某单元中的一个数加入到此数列中（若此数列中有此数，则不加；若此数列中无此数，则加在数列尾）**

   编程思路：

   将内存定义好的数串元素依次取到寄存器中，与要加入的数据比较；

   如非此数，取下一个数继续比较；

   如是此数，则停止比较，结束

   如比较结束也无此数，则将该数加到数尾，并且列的长度加1；结束 

   ```
   DATA 	SEGMENT
   BUF		DB 10, 12, 34, 32,98, 34, 32,99, 23, 51,96
   NUM 	DB 77
   DATA 	ENDS
   CODE 	SEGMENT
   		ASSUME CS:CODE,DS:DATA
   START:		MOV AX, DATA
   		MOV DS, AX
   		LEA BX, BUF
   		MOV CX, BUF
   		MOV AL, NUM
   AGAIN:  INC BX
   		CMP AL, [BX]
   		JNE NEXT
   		JMP EXIT
   NEXT:	LOOP AGAIN
   		INC BYTE PTR BUF；个数加1
   		MOV [BX+1], AL;；加到末尾
   EXIT:	MOV AX,4C00H
   		INT 21H
   CODE 	ENDS
   END START
   ```

10. **在内存已定义好一个容量为20字节的数组，请将数组中为0的项找出，统计0的个数，并删除数组中所有为零的项，将后续项向前移动，进行压缩处理**

    编程思路：

    将数组依次取到寄存器中，每个数与零比较；

    统计0的个数；

    每次发现为0的项，统计后将其删掉，后续项向前移。

    ```
    DATA SEGMENT
    BUF DB 12,23,45,32,12,34,56,78,76,54,65,87,98,0,12,1,0,12,32,43
    DATA ENDS
    CODE SEGMENT
    ASSUME CS:CODE,DS:DATA,ES:DATA
    START: MOV AX, DATA
    	MOV DS,AX	
    	MOV CL, 20
    	MOV CH,0；用来存放0的个数
    	MOV SI,OFFSET BUF
    CLD
    AGAIN:
    	LODSB；取到AL中
    	CMP AL,0
    	JNE NEXT
    	INC CH  ; 发现为0的项，统计后将其删掉，后续项向前移，采用了数据串移动指令
    	MOV DI, SI
    	INC SI
    	PUSH CX	
    	PUSH SI
    	MOV CH,0
    	DEC CX
    REP	MOVSB
    	POP SI
    	POP CX
    	DEC CL
    NEXT:	DEC CL
    	JNZ AGAIN
    EXIT:
    	MOV AX,4C00H
    	INT 21H
    CODE ENDS
    	END START
    ```

11. **将内存字单元BUF1中的内容拆为四个16进制数，并分别转换为相应的ASCII码存于BUF2及其后续的单元中**

    ```
    STACK  SEGMENT STACK
            DW 256 DUP（？）
    STACK  ENDS
    DATA  SEGMENT
    BUF1  DW  37D5H
    BUF2  DB  4 DUP（?）
    DATA  ENDS
    CODE  SEGMENT
           ASSUME  CS：CODE，SS：STACK，DS：DATA
    START：MOV  AX，DATA
           MOV  DS，AX
            MOV  BX，OFFSET BUF1
            MOV  DI，OFFSET BUF2
            MOV  AX，[BX]  ; 取字
            MOV  BX，AX
            MOV  DX，4   ；循环次数
            MOV  CL，4
    LOP：AND  AX，000FH
    OR  AL，30H
    CMP  AL，39H
    JLE  STORE
    ADD  AL，7  ；如果是字母（A,B,C,D,E,F）数字
    STORE：MOV  [DI]，AL
    			INC DI   ；修改指针
    SHR  BX，CL
    MOV  AX，BX
    DEC  DX
    JNZ  LOP
    MOV  AH，4CH
           INT  21H
    CODE  ENDS
           END START
    ```

12. **在数据段的BUFFER到BUFFER+24单元中存放着一个字符串，请判断该字符串中是否存在数字，如有则把X单元置1，如无数字则将X单元置0**

    编程思路：

    （1）将字符串依次取到寄存器中；

    （2）将字符的ASCII码与30H~39H比较，在此范围则为数字；

    （3）发现数字，则置X单元为1，并结束搜索。

    ```
    DATA SEGMENT
    	BUFFER ‘It is a test. Good afternoon. It was Tuesday’
    	COUNT EQU $-BUFFER
    	X DB 0
    DATA ENDS
    CODE SENGMENT
    	ASSUME CS:CODE,DS:DATA
    START:
    	MOV AX, DATA
    	MOV DS,AX
    	MOV CX, COUNT
    	LEA SI, BUFFER
    	CLD
    AGAIN:
    	LODSB
    	CMP AL, 30H
    	JAE APP1
    	JMP NEXT
    APP1: CMP AL,39H
    	JA NEXT
    	INC BYTE PTR X
    	JMP EXIT
    NEXT: LOOP AGAIN
    EXIT: MOV AX,4C00H
    	INT 21H
    CODE ENDS
    END ATART
    ```

13. **从键盘上输入两个字符存于A，B单元中，比较它们的大小，并在屏幕上显示两个数的大小关系**

    ```
    STACK  SEGMENT STACK
            DW 256 DUP（？）
    STACK  ENDS
    DATA  SEGMENT
            A  DB  ？
            B  DB  ？
    DATA  ENDS
    CODE  SEGMENT
            ASSUME  CS：CODE，SS：STACK，DS：DATA
    START： MOV  AX，DATA
    		MOV  DS，AX
            MOV  AH，1；等待键盘输入字符1
            INT  21H
            MOV  A，AL
            MOV  AH，1；等待键盘输入字符2
            INT  21H
            MOV  B，AL
            CMP  A，AL
            JGE  AGB
            MOV  DL，‘B’
            MOV  BL，‘A’
            JMP  DISP
    AGB：MOV  DL，‘A’
    		MOV  BL，‘B’
            DISP：MOV  AH，2
            INT  21H
            MOV  DL，‘>’
            INT  21H
            MOV  DL，BL
            INT   21H
            MOV  AH，4CH
            INT  21H
    CODE  ENDS
            END START
    ```

14. **内存BUF开始的单元中存放6个无序数，请用冒泡法将它们按递增顺序排序**

    ```
    STACK  SEGMENT STACK
            DW 256 DUP（？）
    STACK  ENDS
    DATA  SEGMENT
    		A  DW  34，78，65，21，66，90
    DATA  ENDS
    CODE  SEGMENT
           ASSUME  CS：CODE，SS：STACK，DS：DATA
    START：MOV  AX，DATA
           MOV  DS，AX
    		MOV  CX，6
    		DEC  CX
    A1：MOV  DI，CX
    		MOV  BX，0
    A2：MOV  AX，A[BX]
    		CMP  AX，A[BX+2]
            JLE  A3
            XCHG  AX，A[BX+2]
            MOV  A[BX]，AX
    A3：ADD  BX，2
            LOOP  A2
            MOV  CX，DI
            LOOP  A1
            MOV  AH，4CH
            INT  21H
    CODE  ENDS
    		END START
    ```

15. **编写程序，求1~150之间的能同时被2和3整除的整数之和**

    编程思路：

    从1开始判断每个数是否能被2整除，不能被2整除则更新为下一个数；

    能被2整除则再判断是否能被3整除，如能整除则累加该数；

    当该数更新为150时，则停止

16. **阅读下列程序，写出程序执行后，数据段BUF中十个内存单元中的内容**

    ```
    DATA  SEGMENT
    BUF   DB  0AH，23H，76H，8AH，6FH，0E3H，02H，9DH，55H，39H，0ACH
    KEY   DB  78H
    DATA  ENDS
    CODE  SEGMENT
    		ASSUME  CS：CODE，DS：DATA，ES：DATA
    START：MOV  AX，DATA
            MOV  DS，AX
            MOV  ES，AX
            CLD
            LEA  DI，BUF
            MOV  CL，[DI]
            XOR  CH，CH
            INC  DI
            MOV  AL，KEY
    REPNE  SCASB   ;串搜索 AL-[DI]
            JNE  DONE
            DEC  BUF
            MOV  SI，DI
            DEC  DI
    REP    MOVSB
    DONE：MOV  AH，4CH
    		INT  21H
    CODE  ENDS
    		END  START
    
    程序执行后，数据段BUF的内容还是执行之前的内容。
    如果：
    BUF   DB  0AH，23H，78H，8AH，6FH，0E3H，02H，9DH，55H，39H，0ACH
    则执行后数据段BUF的内容为：
    BUF   DB  0AH，23H， 8AH，6FH，0E3H，02H，9DH，55H，39H，0ACH，0ACH
    
    如果：
    BUF   DB  23H，76H，8AH，6FH，0E3H，02H，9DH，55H，39H，0ACH
    则执行后数据段BUF的内容不变为：
    BUF   DB  23H， 76H，8AH，6FH，0E3H，02H，9DH，55H，39H，0ACH
    ```

17. **分析以下程序段的功能，并指出程序执行后BUF单元存储的是什么信息？**

    ```
    DATA  SEGMENT
    STRN  DB  ‘FGGHY4567AAA32...’，‘$’
    BUF  DB  0
    DATA  ENDS
    CODE  SEGMENT
            ASSUME  CS：CODE，DS：DATA
    START：MOV  AX，DATA      
           MOV  DS，AX
           MOV  AX，0
           MOV  DX，AX 
           LEA  DI，STRN
           MOV  CX，100
           MOV  AL，‘$’
    LP：   CMP  AL，[DI]      (将‘$’与STRN中的字符进行比较)
           JE  DONE 
           INC  DX 
           INC  DI
           LOOP  LP
    DONE： MOV  BUF，DL 
           MOV  AH，4CH
           INT  21H
    CODE  ENDS
           END  START
    ```

    程序执行后，BUF中存放STRN的实际长度（即字符个数）。包括“$”吗？

    **BUF中存放字符串中第一个‘$’的位置**

## 题四

1. **子程序是如何定义和调用的？**

   子程序的定义是由过程定义伪指令来实现的，一个过程是一段程序，以PROC伪指令语句开始，以ENDP伪指令语句结束。格式如下：

   过程名 PROC [NEAR或FAR]

   ...

   过程名 ENDP

   子程序（过程）调用指令CALL的格式为：

   CALL OPRD

2. **什么是子程序的嵌套和递归？**

   一个子程序可以作为调用程序去调用另一个子程序，这种情况就称为子程序的嵌套。嵌套的层次不限，其层数称为嵌套深度。嵌套子程序的设计并没有什么特殊要求，除子程序的调用和返回应正确使用CALL和RET指令外，要注意寄存器的保存和恢复，以避免各层子程序之间发生因使用寄存器冲突而出错的情况。

   在子程序嵌套的情况下，如果一个子程序调用的子程序就是它自身，这就称为递归调用。这样的子程序称为递归子程序。在子程序递归调用时，也不可避免地要用到堆栈，所以递归调用的嵌套层数往往会受堆栈容量的限制。

3. **主程序和子程序之间的参数传递主要有几种方式？每种方式的特点是什么？**

   （1）利用寄存器传递参数

   这是最常用的一种方法，但受到寄存器个数的限制，一般用于参数较少的情况。在主程序中将要传递的参数放入到指定的寄存器中，然后在子程序中再从相应的寄存器获取参数。

   （2）利用内存缓冲区传递参数

   用存储器传递参数的最简单方法是定义位置、格式确定的缓冲存储区，凡是需要过程处理的参数，无论原来存在什么地方，必须按格式要求先传入缓冲区。过程从缓冲区取得数据进行规定的处理，产生的结果按格式要求存入这个或另外的缓冲存储区，调用程序（主程序）再从缓冲区取走结果。

   （3）利用堆栈区传递参数

   将子程序（过程）要用的参数放在堆栈区中，设置好指针（BP），子程序（过程）执行时从堆栈区取出参数，完成相应的功能。

4. **试编写能实现如下功能的过程**

   （1）十进制数转换为ASCII码

   ```
   SUB1  	PROC  FAR
           PUSH  AX
           MOV  AL，BUF1
           AND  AL，0FH
           OR  AL，30H
           MOV  BUF2，AL
           POP  AX
           RET
   SUB1  	ENDP
   ```

   （2）十六进制数转换为ASCII码

   ```
   SUB1  	PROC  FAR
           PUSH  AX
           MOV  AL，BUF1
           AND  AL，0FH
           OR  AL，30H
           CMP  AL，39H
           JLE  EXIT
           ADD  AL，7H
   EXIT：	MOV  BUF2，AL
           POP  AX
           RET
   SUB1  	ENDP
   ```

   （3）数字的ASCII码转换为十六进制数

   ```
   SUB1  	PROC  FAR
           PUSH  AX
           MOV  AL，BUF1
           CMP  AL，39H
           JLE  	NEXT
           SUB  AL，7H
   NEXT：	AND  AL，0FH
           MOV  BUF2，AL
           POP  AX
           RET
   SUB1  ENDP
   ```

   （4）f(x) = 2x^2 +3x–4

   ```
   SUB1  PROC  FAR
       PUSH  AX
       PUSH  BX
       PUSH  CX
       PUSH  DX
       MOV  CX，0
       MOV  AL，X//X是变量名
       MOV  BL，AL 
       MUL  BL //X平方
       MOV  DL，2
       MUL  DL //X平方*2
       ADD  CX，AX//加入CX中
       MOV  AL，BL
       MOV  DL，3 
       MUL  DL   //3*X
       ADD  CX，AX//加入CX中
       SUB  CX，4    //减去4
       MOV  FX，CX //FX是变量名
       POP  DX
       POP  CX
       POP  BX
       POP  AX
   	RET
   SUB1  ENDP（子程序利用存储单元传递参数）
   ```

   （5）非压缩BCD码转换为压缩BCD码

   ```
   BCDTR1  PROC  NEAR
   PUSH  AX
   PUSH  BX
   PUSH  CX
   PUSH  SI
   PUSH  DI
   MOV  SI，OFFSET BUF1  ；非压缩BCD码
   MOV  DI，OFFSET BUF2  ；压缩BCD码
   MOV  AL，[SI]
   AND  AL，0FH
   MOV  BL，[SI+1]
   AND  BL，0FH
   MOV  CL，4
   SHL  BL，CL
   OR  AL，BL
   MOV  [DI]，AL
   POP  DI
   POP  SI
   POP  CX
   POP  BX
   POP  AX
   RET
   BCDTR1  ENDP
   ```

   （6）压缩BCD码转换为非压缩BCD码

   ```
   BCDTR2  PROC  NEAR
   PUSH  AX
   PUSH  CX
   PUSH  SI
   PUSH  DI
   MOV  SI，OFFSET BUF1  ；非压缩BCD码
   MOV  DI，OFFSET BUF2  ；压缩BCD码
   MOV  AL，[DI]
   AND  AL，0FH
   MOV  [SI]，AL
   MOV  AL，[DI]
   MOV  CL，4
   SHR  AL，CL
   MOV  [SI+1]，AL
   POP  DI
   POP  SI
   POP  CX
   POP  AX
   RET
   BCDTR2  ENDP
   ```

5. **下面的子程序有错吗？如果存在错误，将其改正。**

   ```
   ABC  PROC
       PUSH  DX
       XOR  AX，AX
       XOR  DX，DX
   AGAIN：ADD  AX，[BX]
       ADC  DX，0
       INC  BX
       INC  BX
       LOOP  AGAIN
       RET
   ABC  ENDP
   
   改正后如下：
   ABC  PROC
       XOR  AX，AX
       XOR  DX，DX
   AGAIN：ADD  AX，[BX]
       ADC  DX，0
       INC  BX
       INC  BX
       LOOP  AGAIN
       RET
   ABC  ENDP
   ```

   说明：调用此子程序前，在调用程序中需要对BX（累加数据区的首地址）和CX（累加的字个数）进行初始化；并且在调用程序前AX和DX没有被使用；子程序执行后的返回值（数据区的字累加和）在AX和DX中。（子程序利用寄存器传递地址参数，但真正的数据是在存储区中）

   子程序的功能是什么？

6. **分析下面程序段，程序运行后，AL和BL寄存器中的内容是什么？**

   | ...                 |      |                  |               |
   | ------------------- | ---- | ---------------- | ------------- |
   | XOR AL，AL          |      | AL =0            |               |
   | CALL SUBROUT        |      |                  |               |
   | MOV BL，AL          |      | BL = AL=11111111 |               |
   | CALL SUBROUT        |      |                  |               |
   | RCR AL，1           |      |                  | AL =1000 0000 |
   | HLT                 |      |                  |               |
   | SUBROUT PROC   NEAR |      |                  |               |
   | NOT   AL            |      | AL=11111111      | AL=00000000   |
   | JS   NEXT           |      | SF=1             |               |
   | STC                 |      |                  | CF=1          |
   | NEXT：    RET       |      |                  |               |
   | SUBROUT ENDP        |      |                  |               |
   | ...                 |      |                  |               |

   ```
   ...
   XOR  AL，AL
   CALL  SUBROUT
   MOV  BL，AL
   CALL  SUBROUT
   RCR  AL，1
   HLT
   SUBROUT  PROC  NEAR
   NOT  AL
   JS  NEXT
   STC
   NEXT：    RET
   SUBROUT  ENDP
   ...
   ```

   程序运行后，AL的内容为10000000B；BL的内容为11111111B；（利用寄存器传递参数）

7. **分析下列程序，指出程序完成什么功能？**

   ```
   MAIN  PROC  FAR
          MOV  SI，OFFSET SOURCE
   		PUSH  SI
           MOV  DI，OFFSET  DEST
           PUSH  DI
           MOV  CX，100
           PUSH  CX
           CALL  FAR PTR REMOV
   		RET
   MAIN  ENDP
   REMOV  PROC  FAR
           MOV  BP，SP
           MOV  CX，[BP+4]
           MOV  DI，[BP+6]
           MOV  SI，[BP+8]
           CLD
   REP     MOVSB
   		RET 6
   REMOV  ENDP
   ```

   MAIN中初始化源串和目的串，并调用子程序REMOV；子程序REMOV实现字节型数据串的传送。（利用堆栈传递参数）

8. **MAIN中初始化源串和目的串，并调用子程序REMOV；子程序REMOV实现字节型数据串的传送。（利用堆栈传递参数）**

   ```
   STACK  SEGMENT STACK
           DW 256 DUP（？）
   STACK  ENDS
   DATA  SEGMENT
   DAT1  DQ  122354AF76432AB3H
   DAT2  DQ  1187ABC76FE54DD1H
   DAT3  DQ  ？
   DATA  ENDS
   CODE  SEGMENT
          ASSUME  CS：CODE，SS：STACK，DS：DATA
   START：MOV  AX，DATA
          MOV  DS，AX
   CALL  SUBB
   MOV  AH，4CH
          INT  21H
   SUBB  PROC  NEAR
           MOV  BX，OFFSET DAT1
           MOV  SI，OFFSET DAT2
           MOV  DI，OFFSET DAT3
           MOV  CX，4
   		CLC
   AGAIN：MOV  AX，[BX]
           SBB  AX，[SI]
           MOV  [DI]，AX
           INC  BX
           INC  BX
           INC  SI
           INC  SI
           INC  DI
           INC  DI
           LOOP  AGAIN
           RET
   SUBB  ENDP
   CODE  ENDS
          END START
   ```

9. **设计一个子程序，它能完成在屏幕上输出空行的功能，空行的行数在CX寄存器中。试将此功能用于你的程序中。**

   ```
   DISP  	PROC  NEAR
   LOP：	MOV  DL，0DH
           MOV  AH，2
           INT  21H
           MOV  DL，0AH
           INT  21H
           LOOP  LOP // CX-1->CX, 
           RET
   DISP  	ENDP
   ```

10. **编程（包含子程序）实现对两个数组求和的功能，设两个数组的类型相同，数组元素个数也相同。**

    编程思路：

    依次取出两个数组的元素，按序相加，结果存放在和数组中；设置一个计数值，控制加法的次数。

11. **什么叫DOS系统功能调用？什么叫BIOS系统功能调用？**

    在多用户和多任务的环境下，与硬件有关的ROMBIOS资源只允许操作系统这个特殊用户使用，用户只可以使用INT 21H功能调用，包括字符输入、字符输出、磁盘控制、文件管理、记录操作、目录操作、动态存储分配等功能。

    IBMDOS.COM包括一个文件管理程序和一些处理程序，在DOS下运行的程序可以调用这些处理程序。IBMDOS.COM是通过把信息传送给IBMBIO.COM，形成一个或多个BIOS调用，来完成DOS功能调用的。

    BIOS存放在内存的最高端，是由功能模块组成的，可以通过软中断指令调用这些功能模块，故又称为BIOS中断调用。ROM BIOS使用了中断向量码00H~1FH。

    例如：键盘I/O中断调用INT 16H

    该中断调用16H有三个功能，功能号0~2。

      （AH）= 0为从键盘读字符到AL寄存器中。

    入口参数：无。

    出口参数：AL中为键入字符的ASCII码，AH为键入字符的扫描码。

    调用方法为：

    MOV AH，0

    INT 16H

12. **举例说明实现DOS系统功能调用的一般步骤。**

    中断类型21H是DOS功能调用的主体，它提供了众多的非常强大的功能供用户调用，功能号由寄存器AH提供。在发INT 21H软中断之前，应该先准备好入口参数（也称调用参数），并将功能号送入AH寄存器中。

    例如：由键盘输入单个字符

    MOV AH，1        ；系统调用功能号送AH

    INT 21H

    输入字符的ASCII码在AL寄存器中，同时字符显示在屏幕上。

13. **用系统功能调用实现：把键盘输入的十进制数转换为二进制数，并将结果存放到内存单元。**

    编程思路：

    定义键盘输入功能；

    将带符号的十进制数转换为二进制数，此功能可以定义子程序实现；

    将转换后的结果存放到内存单元。

14. **分别用字符显示功能和字符串显示功能来完成在屏幕上显示一个字符串“STUDENT”的功能**

    ```
    STACK  SEGMENT STACK
            DW 256 DUP（？）
    STACK  ENDS
    DATA  SEGMENT
    		BUF  DB ‘STUDENT’， ‘$’
    DATA  ENDS
    CODE  SEGMENT
           ASSUME  CS：CODE，SS：STACK，DS：DATA
    START：MOV  AX，DATA
           MOV  DS，AX
            MOV  BX，OFFSET BUF
            MOV  CL，7
    LOP1：MOV  DL，[BX]
            MOV  AH，2
            INT  21H
            INC  BX
            DEC  CL
            JNZ  LOP1
            MOV  DX，OFFSET BUF
            MOV  AH，9
            INT  21H
            MOV  AH，4CH
           INT  21H
    CODE  ENDS
           END START
    ```

15. **从键盘上输入一行字符，如果这行字符的长度是10，则保存该行字符。然后继续输入下一行字符。按下‘$’输入结束，最后将所有保存的字符串都显示在屏幕上。**

    编程思路：

    在内存设置缓冲区；

    通过键盘输入字符，边输入边统计，并存入内存单元；

    到10个字符，则回车换行；

    再继续输入；

    判断输入字符是否为‘$’，以此决定是否结束，若结束，将内存缓冲区的字符显示在屏幕上。

    ```
    DATAS SEGMENT
       MESS DB 200 DUP('$')  
    DATAS ENDS
    
    CODES SEGMENT
        ASSUME CS:CODES,DS:DATAS
    START:
        MOV AX,DATAS
        MOV DS,AX
        MOV CL,0
        MOV BX, OFFSET MESS
    GETCHAR:    
    MOV AH,1
        INT 21H
        CMP AL,'$' 
        JE EXIT
        INC CL
        CMP CL,10
        JNE NEXT
        MOV [BX],AL
        INC BX 
    CALL CRCL
        MOV CL,0 
        MOV BYTE PTR[BX],0DH
    	INC BX
    	MOV BYTE PTR[BX],0AH
    	INC BX
        JMP GETCHAR
    NEXT:
    	MOV [BX],AL
    	INC BX
    	JMP GETCHAR
    EXIT:
    	MOV DX, OFFSET MESS
    	MOV AH,9
    	INT 21H
        MOV AH,4CH
        INT 21H
    CRCL PROC NEAR
    	MOV DL, 0DH
    	MOV AH,2
    	INT 21H
    	MOV DL, 0AH
    	MOV AH,2
    	INT 21H
    	RET
    CRCL ENDP
    CODES ENDS
        END START
    ```

16. **利用DOS系统功能调用，实现键盘屏幕方式的人机对话。**

    对话内容如下：

    Please input a key (0-9).

    The key is 8（输入的数字显示在此）

    编程思路：

    利用字符串显示方式在屏幕当前光标位置显示如下信息：

    Please input a key (0-9).

    The key is

    启动键盘输入字符，判断是否数字，若数字，则保留；

    将输入的数字显示在当前光标位置

17. **简述汇编程序的执行过程**

    `编辑程序->*.ASM文件->汇编程序MASM->*.OBJ文件->连接程序LINK->*.EXE文件`

18. **汇编程序有哪些功能？**

    检查出源程序中的语法错误，并给出出错信息提示。

    生成源程序的目标代码程序，也可给出列表文件。

    汇编时遇到宏指令即展开

19. **简述典型微机操作系统的特点**

    Windows是微软公司最初在1985年底推出的专用于微型机的操作系统，第一个版本称为Windows 1.0，后来不断更新。随着版本的不断提高，功能不断加强，速度也不断提高。Windows的操作简单，体现在用户界面的高度图形化和选择性上。Windows完全不需要用户自己输入计算机命令，而是像“点菜”一样从给出的命令选单中作出选择，就能得心应手地操纵计算机的运行。Windows的操作简单，也体现在添加新的硬件设备时所提供的即插即用功能。从Windows 95版本开始，微软公司就在Windows设计中容纳了网络驱动程序，并考虑了对网络协议的接纳。由于Windows有良好的兼容性，所以，在系统中既可以运行16位的程序，也可以运行32位的程序。而且，Windows对硬件也实现了良好的兼容，允许在计算机系统中接入当今市场上能与微型机相连的各种外设。

## 其他

**自己搜集的题目**

1. 8086CPU 是一个 16位的微处理器，具有 **16** 位数据总线，20 位地址总线，可寻址空间为 **1M** 字节

2. 在 PC 机中，只能用 10 根地址线对 I/O 端口寻址，可寻址的端口有 **B** 个

   A.256	B.1K	C.64K	D.1M

3. 数制转换

   [124.719]10 = [1111100.10111000]2 = [7C.B8]16 = [235.5014]7 = [00100100100.011100011001]BCD

4. 代码转换

   [-104]10=[11101000]原=[10010111]反=[10011000]补

5. 16 位二进制补码所能表示的最大数是 **A**

   A.32767	B.32768	C.65535	D.65536

6. 下面指令序列测试 AL 中的数是否偶数，若为偶数则转移至 NEXT 处，横线处的指令为 **B** 

   TEST AL，01H

   __ 	NEXT

   A.JNZ	B.JE	C.JS	D.JC

7. 用来存放下一条要取指令的偏移地址的寄存器是 **A**

   A.IP	B.FLAGS	C.BP	D.SP

8. 下面指令中会影响状态标志的是 **D** 指令

   A.MOV	B.LEA	C.PUSH	D.CMP

9. 寄存器间接寻址时，不可以提供偏移地址的寄存器是 **A**

   A.DX	B.BP	C.DI	D.BX

10. 8086 系统中，一个堆栈段中最多可以存放 **C** 个字型的数据

    A.1M	B.64K	C.32K	D.1K

11. 8086/8088 微机系统内存单元的物理地址是 **D** 位的

    A.16	B.8	C.32	D.20

12. 8086 CPU 执行一次 PUSH 指令，堆栈指针 SP 的值  **D**

    A.加1	B.加2	C.减1	D.减2

13. 如果AL的内容为50H，执行TEST AL，01H 指令后，AL的内容为 **C**

    A.49H	B.4FH	C.50H	D.01H

14. 8086/8088 CPU分成 **C** 两个部分，它们是并行工作的

    A.ALU和Cache	B.ALU和BLU	C.EU和BIU	D.EU和Cache

15. 电子计算机的发展历程是（ ）、晶体管时代、（ ）、（ ）

16. 系统总线分为数据总线、（ ）总线和 （ ）总线三种

17. 8086/8088 系统中，存储器的逻辑地包括（ ）地址和（ ）地址

18. 8086/8088 系统中，存储器是分段组织的，每段最大长度是（ ）字节

19. 指令一般包括 （ ）、（ ）两部分

20. 在8086/8088的通用寄存器AX、BC、CX、DX中，用作存储器间址的寄存器为？用作循环控制指令（LOOP）的寄存器为？

21. 8086/8088的四个寄存器？用来存放数据段首地址的寄存器？用来存放代码段首地址的段寄存器？用来存放堆栈段首地址的段寄存器？

22. 程序设计的基本结构有顺序结构、（）、（）

23. 打印机是（ ）设备、扫描仪是（ ）设备

24. 已知数据段有 100 个字节，DS=1200H，分别计算数据段段首、末单元的物理地址

    **12000H、12063H**

25. 判断下列指令的正误，如果有错则简单说明错误原因

    SUB DATA1,[SI]	错，同为存储器操作数

    MUL 50H	错，不能是立即数

    MOV AX,[BX+1]	正确

    XOR AX,[DX]	错，不能用 DX 间接寻址

26. 分别写出完成下面各任务的指令

    将AL寄存器的高四位置1，低四位保持不变	OR AL 0F0H

    将BX寄存器中的带符号数除以8	MOV CL，3	SAR BX，CL

    将DL寄存器中的小写字母的ASCII码转换为相应的大写字母	AND DL，0DFH

27. 下面程序段实现的完整功能是：

    ```
    	SHL BX,1
    	JC ONE
    	MOV DL,'0'
    	JMP NEXT
    ONE:MOV DL,'1'
    NEXT:MOV AH,2
    	INT 21H
    ```

    答：在显示器上显示BX的最高位，0或1

28. 打印所有ASCII字符（1-FFH）

    ```
    //直接输出
    CODES SEGMENT
        ASSUME CS:CODES
    START:
        MOV DL,1	(从1开始)
    NEXT:    MOV AH,2	(显示单个字符)
        INT 21H
        INC DL		(DL加1)
        CMP DL,00	(DL和0比较)	
        JNZ NEXT	(DL不为0，跳转)
        MOV AH,4CH	(程序终止)
        INT 21H
    CODES ENDS
        END START
        
    
    //一行一行输出
    CODES SEGMENT
        ASSUME CS:CODES,DS:DATAS,SS:STACKS
    START:
        MOV AX,DATAS
        MOV DS,AX
        MOV DL,1
        MOV BL,1
    NEXT:    MOV AH,2
        INT 21H
        PUSH DX
        MOV DL,20H
        MOV AH,2
        INT 21H
        POP DX
        INC BL
        CMP BL,10H
        JNZ AGAIN
        MOV BL,1
        PUSH DX
        MOV DL,0AH
        MOV AH,2
        INT 21H
        MOV DL,0DH
        MOV AH,2
        INT 21H
        POP DX
    AGAIN:   INC DL
        CMP DL,00
        JNZ NEXT
        MOV AH,4CH
        INT 21H
    CODES ENDS
        END START
    ```

29. 输出“Hello World”

    ```
    DATAS SEGMENT
    	STRING DB 'Hello World!',13,10,'$' 
    	//13和10分别表示回车符和换行符的ASCII码，执行结果是回车换行；’$’是结束标志，否则不加’$’会出现乱码。
    DATAS ENDS
     
    CODES SEGMENT
    	ASSUME	CS:CODES,DS:DATAS
    START:
    	MOV AX,DATAS
    	MOV DS,AX
    	LEA DX,STRING
    	MOV AH,9	//显示以$结尾的字符串
    	INT 21H
    	MOV AH,4CH
    	INT 21H
    CODES ENDS
    	END START
    ```

30. DATA 开始的单元存放 15 个 8 位无符号数，要将其中的最小数找出来并存放在MIN单元。写出完成此功能的汇编语言程序片段

    ```
    		LEA BX,DATA		;DATA偏移地址送BX
    		MOV CX,14		;设循环次数
    		MOV AL,[BX]		;第一个带符号数送AL
    CHECK:  INC BX
    		CMP AL,[BX]		;两数比较
    		JNZ DONE		;如果AL中的数较小，则转DONE
    		MOV AL,[BX]
    DONE:	LOOP CHECK		;循环次数
    		MOV MIN,AL		;存放最小数
    		HLT
    ```


# 期末考

1. 选择题（~16%

2. 填空题（~25%

3. 简答题（~20%

4. 程序阅读与理解（~25%

5. 设计（程序）（~14%



1. **绪论**

   1. 计算机中数的表示方法

      进制、码制

   2. 计算机的基本结构

      冯诺依曼结构

   3. 微型计算机结构和系统

      三大总线、存储器

   4. 微型计算机的发展概况

2. **8086微处理器**

   1. 8086 CPU的内部结构

      基本功能模块、寄存器

   2. 8086/8088 CPU的引脚功能

   3. 8086的存储器组织

      段地址和偏移地址、存储器的分体结构

3. **寻址方式和指令系统**

   1. 8086的寻址方式

      操作数种类、寻址方式

   2. 指令的机器码表示方法（了解）

   3. 8086的指令系统

      数据传送指令

      算术运算指令

      逻辑运算和移位指令

      字符串处理指令

      控制转移指令

4. **汇编语言程序设计**

   1. 汇编语言程序格式和伪指令
   2. DOS系统功能调用（BIOS中断调用不考）
   3. 汇编语言程序设计方法与实例



